//! This module contains the CircuitInputBuilder, which is an object that takes types from geth /
//! web3 and outputs the circuit inputs.
use crate::eth_types::{self, Address, GethExecStep, GethExecTrace, Word};
use crate::evm::GlobalCounter;
use crate::evm::OpcodeId;
use crate::exec_trace::OperationRef;
use crate::geth_errors::*;
use crate::operation::container::OperationContainer;
use crate::operation::{Op, Operation};
use crate::{BlockConstants, Error};
use core::fmt::Debug;

/// Out of Gas errors by opcode
#[derive(Debug, PartialEq)]
pub enum OogError {
    /// Out of Gas for opcodes which have non-zero constant gas cost
    Constant,
    /// Out of Gas for opcodes MLOAD, MSTORE, MSTORE8, CREATE, RETURN, REVERT, which have pure
    /// memory expansion gas cost
    PureMemory,
    /// Out of Gas for SHA3
    Sha3,
    /// Out of Gas for CALLDATACOPY
    CallDataCopy,
    /// Out of Gas for CODECOPY
    CodeCopy,
    /// Out of Gas for EXTCODECOPY
    ExtCodeCopy,
    /// Out of Gas for RETURNDATACOPY
    ReturnDataCopy,
    /// Out of Gas for LOG
    Log,
    /// Out of Gas for CALL
    Call,
    /// Out of Gas for CALLCODE
    CallCode,
    /// Out of Gas for DELEGATECALL
    DelegateCall,
    /// Out of Gas for CREATE2
    Create2,
    /// Out of Gas for STATICCALL
    StaticCall,
}

/// EVM Execution Error
#[derive(Debug, PartialEq)]
pub enum ExecError {
    /// Always returned for REVERT
    ExecutionReverted,
    /// Invalid Opcode
    InvalidOpcode,
    /// For opcodes who push more than pop
    StackOverflow,
    /// For opcodes which pop, DUP and SWAP, which peek deeper element directly
    StackUnderflow,
    /// Out of Gas
    Oog(OogError),
    /// For SSTORE, LOG0, LOG1, LOG2, LOG3, LOG4, CREATE, CALL, CREATE2, SELFDESTRUCT
    WriteProtection,
    /// For CALL, CALLCODE, DELEGATECALL, STATICCALL
    Depth,
    /// For CALL, CALLCODE
    InsufficientBalance,
    /// For CREATE, CREATE2
    ContractAddressCollision,
    /// contract must not begin with 0xef due to EIP #3541 EVM Object Format (EOF)
    InvalidCode,
    /// For JUMP, JUMPI
    InvalidJump,
    /// For RETURNDATACOPY
    ReturnDataOutOfBounds,
    /// Internal calculation of gas overflow
    GasUintOverflow,
    /// For RETURN in a CREATE, CREATE2
    CodeStoreOutOfGas,
    /// For RETURN in a CREATE, CREATE2
    MaxCodeSizeExceeded,
}

/// An execution step of the EVM.
#[derive(Debug)]
pub struct ExecStep {
    /// The opcode ID
    pub op: OpcodeId,
    /// The global counter when this step was executed
    pub gc: GlobalCounter,
    /// The list of references to Operations in the container
    pub bus_mapping_instance: Vec<OperationRef>,
    /// Error generated by this step
    pub error: Option<ExecError>,
}

impl ExecStep {
    /// Create a new Self from a `geth_step`.
    pub fn new(geth_step: &GethExecStep, gc: GlobalCounter) -> Self {
        ExecStep {
            op: geth_step.op,
            gc,
            bus_mapping_instance: Vec::new(),
            error: None,
        }
    }
}

/// Context of a [`Block`] which can mutate in a [`Transaction`].
#[derive(Debug)]
pub struct BlockContext {
    /// Used to track the global counter in every operation in the block.
    pub gc: GlobalCounter,
}

impl Default for BlockContext {
    fn default() -> Self {
        Self::new()
    }
}

impl BlockContext {
    /// Create a new Self
    pub fn new() -> Self {
        Self {
            gc: GlobalCounter::new(),
        }
    }
}

/// Circuit Input related to a block.
#[derive(Debug)]
pub struct Block {
    /// Constants associated to this block and the chain.
    pub constants: BlockConstants,
    /// Container of operations done in this block.
    pub container: OperationContainer,
    txs: Vec<Transaction>,
}

impl Block {
    /// Create a new block.
    pub fn new<TX>(
        _eth_block: &eth_types::Block<TX>,
        constants: BlockConstants,
    ) -> Self {
        Self {
            constants,
            container: OperationContainer::new(),
            txs: Vec::new(),
        }
    }

    /// Return the list of transactions of this block.
    pub fn txs(&self) -> &[Transaction] {
        &self.txs
    }

    #[cfg(test)]
    pub fn txs_mut(&mut self) -> &mut Vec<Transaction> {
        &mut self.txs
    }
}

#[derive(Debug)]
/// Context of a Call during a [`Transaction`] which can mutate in an [`ExecStep`].
pub struct CallContext {
    address: Address,
}

#[derive(Debug)]
/// Context of a [`Transaction`] which can mutate in an [`ExecStep`].
pub struct TransactionContext {
    call_ctxs: Vec<CallContext>,
}

impl TransactionContext {
    /// Create a new Self.
    pub fn new(eth_tx: &eth_types::Transaction) -> Self {
        let mut call_ctxs = Vec::new();
        if let Some(addr) = eth_tx.to {
            call_ctxs.push(CallContext { address: addr });
        }
        Self { call_ctxs }
    }
}

#[derive(Debug)]
/// Result of the parsing of an Ethereum Transaction.
pub struct Transaction {
    steps: Vec<ExecStep>,
}

impl Transaction {
    /// Create a new Self.
    pub fn new(_eth_tx: &eth_types::Transaction) -> Self {
        Self { steps: Vec::new() }
    }

    /// Return the list of execution steps of this transaction.
    pub fn steps(&self) -> &[ExecStep] {
        &self.steps
    }

    #[cfg(test)]
    pub fn steps_mut(&mut self) -> &mut Vec<ExecStep> {
        &mut self.steps
    }
}

/// Reference to the internal state of the CircuitInputBuilder in a particular [`ExecStep`].
pub struct CircuitInputStateRef<'a> {
    /// Block
    pub block: &'a mut Block,
    /// Block Context
    pub block_ctx: &'a mut BlockContext,
    /// Transaction
    pub tx: &'a mut Transaction,
    /// Transaction Context
    pub tx_ctx: &'a mut TransactionContext,
    /// Step
    pub step: &'a mut ExecStep,
}

impl<'a> CircuitInputStateRef<'a> {
    /// Push an [`Operation`] into the [`OperationContainer`] with the next [`GlobalCounter`] and
    /// then adds a reference to the stored operation ([`OperationRef`]) inside the bus-mapping
    /// instance of the current [`ExecStep`].  Then increase the block_ctx [`GlobalCounter`] by
    /// one.
    pub fn push_op<T: Op>(&mut self, op: T) {
        let op_ref = self
            .block
            .container
            .insert(Operation::new(self.block_ctx.gc.inc_pre(), op));
        self.step.bus_mapping_instance.push(op_ref);
    }
}

#[derive(Debug)]
/// Builder to generate a complete circuit input from data gathered from a geth instance.
/// This structure is the centre of the crate and is intended to be the only
/// entry point to it. The `CircuitInputBuilder` works in several steps:
///
/// 1. Take a [`eth_types::Block`] to build the circuit input associated with the block.
/// 2. For each [`eth_types::Transaction`] in the block, take the [`eth_types::GethExecTrace`] to
///    build the circuit input associated with each transaction, and the bus-mapping operations
///    associated with each `eth_types::GethExecStep`] in the [`eth_types::GethExecTrace`].
///
/// The generated bus-mapping operations are:
/// [`StackOp`](crate::operation::StackOp)s,
/// [`MemoryOp`](crate::operation::MemoryOp)s and
/// [`StorageOp`](crate::operation::StorageOp), which correspond to each
/// [`OpcodeId`](crate::evm::OpcodeId)s used in each `ExecTrace` step so that the State Proof
/// witnesses are already generated on a structured manner and ready to be added into the State
/// circuit.
pub struct CircuitInputBuilder {
    /// Block
    pub block: Block,
    /// Block Context
    pub block_ctx: BlockContext,
}

impl<'a> CircuitInputBuilder {
    /// Create a new CircuitInputBuilder from the given `eth_block` and `constants`.
    pub fn new<TX>(
        eth_block: eth_types::Block<TX>,
        constants: BlockConstants,
    ) -> Self {
        Self {
            block: Block::new(&eth_block, constants),
            block_ctx: BlockContext::new(),
        }
    }

    /// Obtain a mutable reference to the state that the `CircuitInputBuilder` maintains,
    /// contextualized to a particular transaction and a particular execution step in that
    /// transaction.
    pub fn state_ref(
        &'a mut self,
        tx: &'a mut Transaction,
        tx_ctx: &'a mut TransactionContext,
        step: &'a mut ExecStep,
    ) -> CircuitInputStateRef {
        CircuitInputStateRef {
            block: &mut self.block,
            block_ctx: &mut self.block_ctx,
            tx,
            tx_ctx,
            step,
        }
    }

    /// Handle a transaction with its corresponding execution trace to generate all the associated
    /// operations.  Each operation is registered in `self.block.container`, and each step stores
    /// the [`OperationRef`] to each of the generated operations.
    pub fn handle_tx(
        &mut self,
        eth_tx: &eth_types::Transaction,
        geth_trace: &GethExecTrace,
    ) -> Result<(), Error> {
        let mut tx = Transaction::new(eth_tx);
        let mut tx_ctx = TransactionContext::new(eth_tx);
        for (index, geth_step) in geth_trace.struct_logs.iter().enumerate() {
            let mut step = ExecStep::new(geth_step, self.block_ctx.gc);
            let mut state_ref = self.state_ref(&mut tx, &mut tx_ctx, &mut step);
            geth_step.op.gen_associated_ops(
                &mut state_ref,
                &geth_trace.struct_logs[index..],
            )?;
            tx.steps.push(step);
        }
        self.block.txs.push(tx);
        Ok(())
    }
}

fn get_step_reported_error(step: &GethExecStep) -> Option<ExecError> {
    return if let Some(error) = &step.error {
        Some(if error == GETH_ERR_GAS_UINT_OVERFLOW {
            ExecError::GasUintOverflow
        } else if error == GETH_ERR_WRITE_PROTECTION {
            ExecError::WriteProtection
        } else if error == GETH_ERR_OUT_OF_GAS {
            let oog_err = match step.op {
                OpcodeId::SHA3 => OogError::Sha3,
                OpcodeId::CALLDATACOPY => OogError::CallDataCopy,
                OpcodeId::CODECOPY => OogError::CodeCopy,
                OpcodeId::EXTCODECOPY => OogError::ExtCodeCopy,
                OpcodeId::RETURNDATACOPY => OogError::ReturnDataCopy,
                OpcodeId::LOG0
                | OpcodeId::LOG2
                | OpcodeId::LOG3
                | OpcodeId::LOG4 => OogError::ReturnDataCopy,
                OpcodeId::CALL => OogError::Call,
                OpcodeId::CALLCODE => OogError::CallCode,
                OpcodeId::DELEGATECALL => OogError::DelegateCall,
                OpcodeId::CREATE2 => OogError::Create2,
                OpcodeId::STATICCALL => OogError::StaticCall,
                OpcodeId::MLOAD
                | OpcodeId::MSTORE
                | OpcodeId::MSTORE8
                | OpcodeId::CREATE
                | OpcodeId::RETURN
                | OpcodeId::REVERT => OogError::PureMemory,
                _ => OogError::Constant,
            };
            ExecError::Oog(oog_err)
        } else if error.starts_with(GETH_ERR_STACK_OVERFLOW) {
            ExecError::StackOverflow
        } else if error.starts_with(GETH_ERR_STACK_UNDERFLOW) {
            ExecError::StackUnderflow
        } else if error.starts_with(GETH_ERR_INVALID_OPCODE) {
            ExecError::InvalidOpcode
        } else {
            panic!("Unknown GethExecStep.error: {}", error);
        })
    } else {
        None
    };
}

impl<'a> CircuitInputStateRef<'a> {
    fn get_step_err(
        &self,
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> Option<ExecError> {
        if let Some(error) = get_step_reported_error(step) {
            return Some(error);
        }
        assert!(step.error.is_none());

        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        let next_result = next_step
            .map(|s| s.stack.last().unwrap_or(Word::zero()))
            .unwrap_or(Word::zero());

        // Return from a call with a failure, without calling RETURN
        if step.op != OpcodeId::RETURN
            && step.depth != next_depth
            && next_result == Word::zero()
        {
            return Some(match step.op {
                OpcodeId::REVERT => ExecError::ExecutionReverted,
                OpcodeId::JUMP | OpcodeId::JUMPI => ExecError::InvalidJump,
                OpcodeId::RETURNDATACOPY => ExecError::ReturnDataOutOfBounds,
                _ => {
                    panic!("Cannot figure out call failure error in {:?}", step)
                }
            });
        }

        // Return from a {CREATE, CREATE2} with a failure, via RETURN
        // TODO: if not self.tx_ctx.is_root and self.tx_ctx.is_create {
        if step.op == OpcodeId::RETURN && next_result == Word::zero() {
            let offset = step.stack.nth_last(0).unwrap();
            let length = step.stack.nth_last(1).unwrap();
            if length > Word::from(0x6000) {
                return Some(ExecError::MaxCodeSizeExceeded);
            } else if length > Word::zero()
                && step.memory.0.len() > 0
                && step.memory.0.get(offset.low_u64() as usize) == Some(&0xef)
            {
                return Some(ExecError::InvalidCode);
            } else if Word::from(200) * length > Word::from(step.gas.0) {
                return Some(ExecError::CodeStoreOutOfGas);
            } else {
                panic!("Cannot figure out RETURN error in {:?}", step);
            }
        }
        // }

        // The *CALL* code was not executed
        let next_pc = next_step.map(|s| s.pc.0).unwrap_or(1);
        if [
            OpcodeId::CALL,
            OpcodeId::CALLCODE,
            OpcodeId::DELEGATECALL,
            OpcodeId::STATICCALL,
            OpcodeId::CREATE,
            OpcodeId::CREATE2,
        ]
        .contains(&step.op)
            && next_result == Word::zero()
            && next_pc != 0
        {
            if step.depth == 1025 {
                return Some(ExecError::Depth);
            }
            // TODO: address_collision
            if step.op == OpcodeId::CREATE2 {
                // NOTE: We don't expect Address Collision in CREATE because in that case, the
                // Address is always unique (the probability of collision is negligible).
                let _value = step.stack.nth_last(0).unwrap();
                let _offset = step.stack.nth_last(1).unwrap();
                let _length = step.stack.nth_last(2).unwrap();
                let _salt = step.stack.nth_last(3).unwrap();
                // TODO: Calculate address
                let _address = Address::zero();
                // TODO:
                // if Some(_) = self.get_account(_address) {
                //      return Some(ExecError::ContractAddressCollision);
                // }
            }

            // TODO: insufficient_balance
            let _value = match step.op {
                OpcodeId::CALL | OpcodeId::CALLCODE => {
                    step.stack.nth_last(2).unwrap()
                }
                OpcodeId::CREATE | OpcodeId::CREATE2 => {
                    step.stack.nth_last(0).unwrap()
                }
                _ => Word::zero(),
            };
            // TODO
            // let caller_address = self.tx_ctx.caller_addr();
            // let caller = self.get_account(caller_address)
            // if caller.balance < value {
            //      return Some(ExecError::InsufficientBalance);
            // }

            panic!(
                "Cannot figure out *CALL* code not executed error in {:?}",
                step
            );
        }

        None
    }
}

#[cfg(test)]
mod tracer_tests {
    use super::*;
    use crate::{
        bytecode,
        bytecode::Bytecode,
        eth_types::Word,
        evm::{stack::Stack, Gas, OpcodeId},
        mock, word,
    };

    // Helper struct that contains a CircuitInputBuilder, a particuar tx and a particular execution
    // step so that we can easily get a CircuitInputStateRef to have a context in order to get the
    // error at a given step.
    struct CircuitInputBuilderTx {
        builder: CircuitInputBuilder,
        tx: Transaction,
        tx_ctx: TransactionContext,
        step: ExecStep,
    }

    impl CircuitInputBuilderTx {
        fn new(block: &mock::BlockData, geth_step: &GethExecStep) -> Self {
            Self {
                builder: CircuitInputBuilder::new(
                    block.eth_block.clone(),
                    block.block_ctants.clone(),
                ),
                tx: Transaction::new(&block.eth_tx),
                tx_ctx: TransactionContext::new(&block.eth_tx),
                step: ExecStep::new(geth_step, GlobalCounter(0)),
            }
        }

        fn state_ref<'a>(&'a mut self) -> CircuitInputStateRef {
            self.builder.state_ref(
                &mut self.tx,
                &mut self.tx_ctx,
                &mut self.step,
            )
        }
    }

    //
    // Errors ignored
    //

    fn check_err_depth(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        [
            OpcodeId::CALL,
            OpcodeId::CALLCODE,
            OpcodeId::DELEGATECALL,
            OpcodeId::STATICCALL,
            OpcodeId::CREATE,
            OpcodeId::CREATE2,
        ]
        .contains(&step.op)
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && step.depth == 1025
    }

    #[test]
    fn tracer_err_depth() {
        // Recursive CALL will exaust the call depth
        let code = bytecode! {
                 PUSH1(0x0) // retLength
                 PUSH1(0x0) // retOffset
                 PUSH1(0x0) // argsLength
                 PUSH1(0x0) // argsOffset
                 PUSH1(0x42) // value
                 PUSH32(word!("0x0000000000000000000000000000000000000000")) // addr
                 PUSH32(0x8_000_000_000_000u64) // gas
                 CALL
                 PUSH2(0xab)
                 STOP
        };
        let block = mock::BlockData::new_single_tx_trace_code_gas(
            &code,
            Gas(1_000_000_000_000_000u64),
        )
        .unwrap();
        let struct_logs = block.geth_trace.struct_logs;

        // get last CALL
        let (index, last_step) = struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::CALL)
            .unwrap();
        assert_eq!(last_step.op, OpcodeId::CALL);
        assert_eq!(last_step.depth, 1025u16);
        // Unfortunately the trace doesn't record errors generated by a CALL.  We only get the
        // success = 0 the next step's stack
        assert_eq!(last_step.error, None);
        assert_eq!(struct_logs[index + 1].op, OpcodeId::PUSH2);
        assert_eq!(struct_logs[index + 1].depth, 1025u16);
        assert_eq!(struct_logs[index + 1].stack, Stack(vec![Word::from(0)])); // success = 0
        assert_eq!(struct_logs[index + 2].op, OpcodeId::STOP);
        assert_eq!(struct_logs[index + 2].depth, 1025u16);

        // Check
        assert_eq!(
            check_err_depth(&last_step, struct_logs.get(index + 1)),
            true
        );
    }

    // TODO
    fn check_err_insufficient_balance(
        _step: &GethExecStep,
        _next_step: Option<&GethExecStep>,
    ) -> bool {
        unimplemented!()
    }

    #[test]
    fn tracer_err_insufficient_balance() {
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH32(Word::from(0x1_000)) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            CALL

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH1(0x01) // value
            PUSH1(0x02) // key
            SSTORE

            PUSH3(0xbb)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();
        let struct_logs = block.geth_trace.struct_logs;

        // get last CALL
        let (index, last_step) = struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::CALL)
            .unwrap();
        // println!("{:#?}", &struct_logs[index - 1..index + 3]);
        // Unfortunately the trace doesn't record errors generated by a CALL.  We only get the
        // success = 0 the next step's stack
        assert_eq!(last_step.error, None);
        assert_eq!(struct_logs[index + 1].op, OpcodeId::PUSH2);
        assert_eq!(struct_logs[index + 1].stack, Stack(vec![Word::from(0)])); // success = 0
    }

    fn check_err_address_collision(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        // TODO: calculate address and check it against existing addresses in the state trie
        let _value = step.stack.nth_last(0).unwrap();
        let _offset = step.stack.nth_last(1).unwrap();
        let _length = step.stack.nth_last(2).unwrap();
        step.op == OpcodeId::CREATE2
            && step.error.is_none()
            && next_step.map(|s| s.pc.0).unwrap_or(1) != 0
            && result(next_step) == Word::zero()
    }

    #[test]
    fn tracer_err_address_collision() {
        let code_creator = bytecode! {
            PUSH1(0x00) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            RETURN
        };

        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH1(0x00) // salt
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE2

            PUSH1(0x00) // salt
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE2

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();
        let struct_logs = block.geth_trace.struct_logs;

        // get last CREATE2
        let (index, last_step) = struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::CREATE2)
            .unwrap();
        // println!("{:#?}", &struct_logs[index - 5..index + 3]);
        assert_eq!(
            check_err_address_collision(
                &struct_logs[index],
                struct_logs.get(index + 1)
            ),
            true
        );
    }

    fn check_err_code_store_out_of_gas(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        // TODO: check CallContext is inside Create or Create2
        let length = step.stack.nth_last(1).unwrap();
        step.op == OpcodeId::RETURN
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && Word::from(200) * length > Word::from(step.gas.0)
    }

    #[test]
    fn tracer_err_code_store_out_of_gas() {
        let code_len = 0x100;
        let code_creator = bytecode! {
            PUSH1(Word::zero()) // value
            PUSH32(code_len) // offset
            MSTORE
            PUSH32(code_len) // length
            PUSH1(0x00) // offset
            RETURN
        };

        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH32(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();
        let struct_logs = block.geth_trace.struct_logs;

        // get last RETURN
        let (index, last_step) = struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        // println!("{:#?}", &struct_logs[index - 5..index + 3]);
        assert_eq!(
            check_err_code_store_out_of_gas(
                &struct_logs[index],
                struct_logs.get(index + 1)
            ),
            true
        );
    }

    fn check_err_invalid_code(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        // TODO: check CallContext is inside Create or Create2
        let offset = step.stack.nth_last(0).unwrap();
        let length = step.stack.nth_last(1).unwrap();
        println!("DBG {:#?}", step);
        step.op == OpcodeId::RETURN
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && length > Word::zero()
            && step.memory.0.len() > 0
            && step.memory.0.get(offset.low_u64() as usize) == Some(&0xef)
    }

    #[test]
    fn tracer_err_invalid_code() {
        let code_creator = bytecode! {
            PUSH32(word!("0xef00000000000000000000000000000000000000000000000000000000000000")) // value
            PUSH1(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            RETURN
        };

        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH1(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURN
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_invalid_code(step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::InvalidCode)
        );
    }

    fn check_err_max_code_size_exceeded(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        // TODO: check CallContext is inside Create or Create2
        let length = step.stack.nth_last(1).unwrap();
        step.op == OpcodeId::RETURN
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && length > Word::from(0x6000)
    }

    #[test]
    fn tracer_err_max_code_size_exceeded() {
        let code_len = 0x6000 + 1;
        let code_creator = bytecode! {
            PUSH1(Word::zero()) // value
            PUSH32(code_len) // offset
            MSTORE
            PUSH32(code_len) // length
            PUSH1(0x00) // offset
            RETURN
        };

        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x100_000) // gas
            CALL

            PUSH2(0xaa)
        };

        let mut code_b = Bytecode::default();
        // pad code_creator to multiple of 32 bytes
        let len = code_creator.code().len();
        let code_creator: Vec<u8> = code_creator
            .code()
            .iter()
            .cloned()
            .chain(0u8..((32 - len % 32) as u8))
            .collect();
        for (index, word) in code_creator.chunks(32).enumerate() {
            code_b.push(32, Word::from_big_endian(word));
            code_b.push(32, Word::from(index * 32));
            code_b.write_op(OpcodeId::MSTORE);
        }
        let code_b_end = bytecode! {
            PUSH32(len) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // value
            CREATE

            PUSH3(0xbb)
        };
        code_b.append(&code_b_end);
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURN
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURN)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_max_code_size_exceeded(step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::MaxCodeSizeExceeded)
        );
    }

    //
    // Errors not reported
    //

    fn result(step: Option<&GethExecStep>) -> Word {
        step.map(|s| s.stack.last().unwrap_or(Word::zero()))
            .unwrap_or(Word::zero())
    }

    fn check_err_invalid_jump(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        [OpcodeId::JUMP, OpcodeId::JUMPI].contains(&step.op)
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && step.depth != next_depth
    }

    #[test]
    fn tracer_err_invalid_jump() {
        let code = bytecode! {
            PUSH1(0x10)
            JUMP
            STOP
        };
        let index = 1; // JUMP
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();
        assert_eq!(block.geth_trace.struct_logs.len(), 2);
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_invalid_jump(step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::InvalidJump)
        );

        // With CALL

        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            STATICCALL

            PUSH2(0xaa)
        };
        let index = 8; // JUMP
        let block = mock::BlockData::new_single_tx_trace_code_2(&code_a, &code)
            .unwrap();
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_invalid_jump(step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::InvalidJump)
        );
    }

    fn check_err_execution_reverted(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        step.op == OpcodeId::REVERT
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && step.depth != next_depth
    }

    #[test]
    fn tracer_err_execution_reverted() {
        let code = bytecode! {
            PUSH1(0x0)
            PUSH2(0x0)
            REVERT
            PUSH3(0x12)
            STOP
        };
        let index = 2; // REVERT
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();
        assert_eq!(block.geth_trace.struct_logs.len(), 3);
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_execution_reverted(step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::ExecutionReverted)
        );

        // With CALL

        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            CALL

            PUSH2(0xaa)
        };
        let index = 10; // REVERT
        let block = mock::BlockData::new_single_tx_trace_code_2(&code_a, &code)
            .unwrap();
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_execution_reverted(&step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::ExecutionReverted)
        );
    }

    fn check_err_return_data_out_of_bounds(
        step: &GethExecStep,
        next_step: Option<&GethExecStep>,
    ) -> bool {
        let next_depth = next_step.map(|s| s.depth).unwrap_or(0);
        step.op == OpcodeId::RETURNDATACOPY
            && step.error.is_none()
            && result(next_step) == Word::zero()
            && step.depth != next_depth
    }

    #[test]
    fn tracer_err_return_data_out_of_bounds() {
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH1(0x0) // value
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            CALL

            PUSH1(0x02) // length
            PUSH1(0x00) // offset
            PUSH1(0x00) // destOffset
            RETURNDATACOPY

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH2(0x42) // value
            PUSH2(0x00) // offset
            MSTORE
            PUSH1(0x01) // length
            PUSH1(0x00) // offset
            RETURN
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        // get last RETURNDATACOPY
        let (index, step) = block
            .geth_trace
            .struct_logs
            .iter()
            .enumerate()
            .rev()
            .find(|(_, s)| s.op == OpcodeId::RETURNDATACOPY)
            .unwrap();
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(check_err_return_data_out_of_bounds(&step, next_step), true);

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::ReturnDataOutOfBounds)
        );
    }

    //
    // Errors Reported
    //

    #[test]
    fn tracer_err_gas_uint_overflow() {
        let code = bytecode! {
            PUSH32(0x42) // value
            PUSH32(0x1_000_000_000_000_000_000u128) // offset
            MSTORE
        };
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = 2; // MSTORE
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::MSTORE);
        assert_eq!(step.error, Some(GETH_ERR_GAS_UINT_OVERFLOW.to_string()));

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::GasUintOverflow)
        );
    }

    #[test]
    fn tracer_err_invalid_opcode() {
        let mut code = bytecode::Bytecode::default();
        code.write_op(OpcodeId::PC);
        code.write(0x0f);
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = block.geth_trace.struct_logs.len() - 1; // 0x0f
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::INVALID(0x0f));
        assert_eq!(
            step.error,
            Some(format!(
                "{}: opcode 0xf not defined",
                GETH_ERR_INVALID_OPCODE
            ))
        );

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::InvalidOpcode)
        );
    }

    #[test]
    fn tracer_err_write_protection() {
        let code_a = bytecode! {
            PUSH1(0x0) // retLength
            PUSH1(0x0) // retOffset
            PUSH1(0x0) // argsLength
            PUSH1(0x0) // argsOffset
            PUSH32(word!("0x0000000000000000000000000000000000000123")) // addr
            PUSH32(0x10_000) // gas
            STATICCALL

            PUSH2(0xaa)
        };
        let code_b = bytecode! {
            PUSH1(0x01) // value
            PUSH1(0x02) // key
            SSTORE

            PUSH3(0xbb)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_2(&code_a, &code_b)
                .unwrap();

        let index = 9; // SSTORE
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(step.op, OpcodeId::SSTORE);
        assert_eq!(step.error, Some(GETH_ERR_WRITE_PROTECTION.to_string()));

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::WriteProtection)
        );
    }

    #[test]
    fn tracer_err_out_of_gas() {
        let code = bytecode! {
            PUSH1(0x0)
            PUSH1(0x1)
            PUSH1(0x2)
        };
        let block =
            mock::BlockData::new_single_tx_trace_code_gas(&code, Gas(4))
                .unwrap();
        let struct_logs = block.geth_trace.struct_logs;

        assert_eq!(struct_logs[1].error, Some(GETH_ERR_OUT_OF_GAS.to_string()));
    }

    #[test]
    fn tracer_err_stack_overflow() {
        let mut code = bytecode::Bytecode::default();
        for i in 0..1025 {
            code.push(2, Word::from(i));
        }
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = block.geth_trace.struct_logs.len() - 1; // PUSH2
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(
            step.error,
            Some(format!("{} 1024 (1023)", GETH_ERR_STACK_OVERFLOW))
        );

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::StackOverflow)
        );
    }

    #[test]
    fn tracer_err_stack_underflow() {
        let code = bytecode! {
            SWAP5
        };
        let block = mock::BlockData::new_single_tx_trace_code(&code).unwrap();

        let index = 0; // SWAP5
        let step = &block.geth_trace.struct_logs[index];
        let next_step = block.geth_trace.struct_logs.get(index + 1);
        assert_eq!(
            step.error,
            Some(format!("{} (0 <=> 6)", GETH_ERR_STACK_UNDERFLOW))
        );

        let mut builder = CircuitInputBuilderTx::new(&block, &step);
        assert_eq!(
            builder.state_ref().get_step_err(&step, next_step),
            Some(ExecError::StackUnderflow)
        );
    }
}
